{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/factory.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The original C++ code and copyright notice are from the [Boost library]{@link http://www.boost.org/doc/libs/1_60_0/boost/math/tools/rational.hpp}. The implementation has been modified for JavaScript.\n*\n* ```text\n* (C) Copyright John Maddock 2006.\n*\n* Use, modification and distribution are subject to the\n* Boost Software License, Version 1.0. (See accompanying file\n* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nvar float64ToFloat32 = require( '@stdlib/number-float64-base-to-float32' );\nvar absf = require( '@stdlib/math-base-special-absf' );\n\n\n// MAIN //\n\n/**\n* Evaluates a rational function (i.e., the ratio of two polynomials described by the coefficients stored in \\\\(P\\\\) and \\\\(Q\\\\)) using single-precision floating-point arithmetic.\n*\n* ## Notes\n*\n* -   Coefficients should be sorted in ascending degree.\n* -   The implementation uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @param {NumericArray} P - numerator polynomial coefficients sorted in ascending degree\n* @param {NumericArray} Q - denominator polynomial coefficients sorted in ascending degree\n* @param {number} x - value at which to evaluate the rational function\n* @returns {number} evaluated rational function\n*\n* @example\n* var Float32Array = require( '@stdlib/array-float32' );\n*\n* var P = new Float32Array( [ -6.0, -5.0 ] );\n* var Q = new Float32Array( [ 3.0, 0.5 ] );\n*\n* var v = evalrationalf( P, Q, 6.0 ); //  => ( -6*6^0 - 5*6^1 ) / ( 3*6^0 + 0.5*6^1 ) = (-6-30)/(3+3)\n* // returns -6.0\n*\n* @example\n* var Float32Array = require( '@stdlib/array-float32' );\n*\n* // 2x^3 + 4x^2 - 5x^1 - 6x^0 => degree 4\n* var P = new Float32Array( [ -6.0, -5.0, 4.0, 2.0 ] );\n*\n* // 0.5x^1 + 3x^0 => degree 2\n* var Q = new Float32Array( [ 3.0, 0.5, 0.0, 0.0 ] ); // zero-padded\n*\n* var v = evalrationalf( P, Q, 6.0 ); // => ( -6*6^0 - 5*6^1 + 4*6^2 + 2*6^3 ) / ( 3*6^0 + 0.5*6^1 + 0*6^2 + 0*6^3 ) = (-6-30+144+432)/(3+3)\n* // returns ~90.0\n*/\nfunction evalrationalf( P, Q, x ) {\n\tvar len;\n\tvar s1;\n\tvar s2;\n\tvar i;\n\n\tlen = P.length;\n\tif ( len === 0 ) {\n\t\treturn NaN;\n\t}\n\tif ( len !== Q.length ) {\n\t\treturn NaN;\n\t}\n\tif ( x === 0.0 || len === 1 ) {\n\t\treturn float64ToFloat32( P[ 0 ] / Q[ 0 ] );\n\t}\n\t// Use Horner's method...\n\tif ( absf( x ) <= 1.0 ) {\n\t\ts1 = P[ len-1 ];\n\t\ts2 = Q[ len-1 ];\n\t\tfor ( i = len-2; i >= 0; --i ) {\n\t\t\ts1 = float64ToFloat32( s1 * x );\n\t\t\ts2 = float64ToFloat32( s2 * x );\n\t\t\ts1 = float64ToFloat32( s1 + P[ i ] );\n\t\t\ts2 = float64ToFloat32( s2 + Q[ i ] );\n\t\t}\n\t} else {\n\t\tx = float64ToFloat32( 1.0 / x ); // use inverse to avoid overflow\n\t\ts1 = P[ 0 ];\n\t\ts2 = Q[ 0 ];\n\t\tfor ( i = 1; i < len; ++i ) {\n\t\t\ts1 = float64ToFloat32( s1 * x );\n\t\t\ts2 = float64ToFloat32( s2 * x );\n\t\t\ts1 = float64ToFloat32( s1 + P[ i ] );\n\t\t\ts2 = float64ToFloat32( s2 + Q[ i ] );\n\t\t}\n\t}\n\treturn float64ToFloat32( s1 / s2 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = evalrationalf;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar float64ToFloat32 = require( '@stdlib/number-float64-base-to-float32' );\nvar Fcn = require( '@stdlib/function-ctor' );\nvar evalrationalf = require( './main.js' );\n\n\n// MAIN //\n\n/**\n* Generates a function for evaluating a rational function using single-precision floating-point arithmetic.\n*\n* ## Notes\n*\n* -   The compiled function uses [Horner's rule][horners-method] for efficient computation.\n*\n* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method\n*\n* @param {NumericArray} P - numerator polynomial coefficients sorted in ascending degree\n* @param {NumericArray} Q - denominator polynomial coefficients sorted in ascending degree\n* @returns {Function} function for evaluating a rational function\n*\n* @example\n* var P = [ 20.0, 8.0, 3.0 ];\n* var Q = [ 10.0, 9.0, 1.0 ];\n*\n* var rational = factory( P, Q );\n*\n* var v = rational( 10.0 ); // => (20*10^0 + 8*10^1 + 3*10^2) / (10*10^0 + 9*10^1 + 1*10^2) = (20+80+300)/(10+90+100)\n* // returns 2.0\n*\n* v = rational( 2.0 ); // => (20*2^0 + 8*2^1 + 3*2^2) / (10*2^0 + 9*2^1 + 1*2^2) = (20+16+12)/(10+18+4)\n* // returns 1.5\n*/\nfunction factory( P, Q ) {\n\tvar f;\n\tvar r;\n\tvar n;\n\tvar m;\n\tvar i;\n\n\t// Avoid exceeding maximum stack size on V8 :(. Note that the value of `500` was empirically determined...\n\tif ( P.length > 500 ) {\n\t\treturn rational;\n\t}\n\t// Code generation. Start with the function definition...\n\tf = 'return function evalrationalf(x){';\n\n\t// Create the function body...\n\tn = P.length;\n\n\t// Declare variables...\n\tf += 'var ax,s1,s2;';\n\n\t// If no coefficients, the function always returns NaN...\n\tif ( n === 0 ) {\n\t\tf += 'return NaN;';\n\t}\n\t// If P and Q have different lengths, the function always returns NaN...\n\telse if ( n !== Q.length ) {\n\t\tf += 'return NaN;';\n\t}\n\t// If P and Q have only one coefficient, the function always returns the ratio of the first coefficients...\n\telse if ( n === 1 ) {\n\t\tr = float64ToFloat32( P[ 0 ] / Q[ 0 ] );\n\t\tf += 'return ' + r + ';';\n\t}\n\t// If more than one coefficient, apply Horner's method to both the numerator and denominator...\n\telse {\n\t\t// If `x == 0`, return the ratio of the first coefficients...\n\t\tr = float64ToFloat32( P[ 0 ] / Q[ 0 ] );\n\t\tf += 'if(x===0.0){return ' + r + ';}';\n\n\t\t// Compute the absolute value of `x`...\n\t\tf += 'if(x<0.0){ax=-x;}else{ax=x;}';\n\n\t\t// If `abs(x) <= 1`, evaluate the numerator and denominator of the rational function using Horner's method...\n\t\tf += 'if(ax<=1.0){';\n\t\tf += 's1 = f64_to_f32(' + P[ 0 ];\n\t\tm = n - 1;\n\t\tfor ( i = 1; i < n; i++ ) {\n\t\t\tf += '+f64_to_f32(x*';\n\t\t\tif ( i < m ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += P[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < 2*m; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\t\tf += 's2 = f64_to_f32(' + Q[ 0 ];\n\t\tm = n - 1;\n\t\tfor ( i = 1; i < n; i++ ) {\n\t\t\tf += '+f64_to_f32(x*';\n\t\t\tif ( i < m ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += Q[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < 2*m; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\n\t\t// Close the if statement...\n\t\tf += '}else{';\n\n\t\t// If `abs(x) > 1`, evaluate the numerator and denominator via the inverse to avoid overflow...\n\t\tf += 'x = f64_to_f32(1.0/x);';\n\t\tm = n - 1;\n\t\tf += 's1 = f64_to_f32(' + P[ m ];\n\t\tfor ( i = m - 1; i >= 0; i-- ) {\n\t\t\tf += '+f64_to_f32(x*';\n\t\t\tif ( i > 0 ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += P[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < 2*m; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\n\t\tm = n - 1;\n\t\tf += 's2 = f64_to_f32(' + Q[ m ];\n\t\tfor ( i = m - 1; i >= 0; i-- ) {\n\t\t\tf += '+f64_to_f32(x*';\n\t\t\tif ( i > 0 ) {\n\t\t\t\tf += '(';\n\t\t\t}\n\t\t\tf += Q[ i ];\n\t\t}\n\t\t// Close all the parentheses...\n\t\tfor ( i = 0; i < 2*m; i++ ) {\n\t\t\tf += ')';\n\t\t}\n\t\tf += ';';\n\n\t\t// Close the else statement...\n\t\tf += '}';\n\n\t\t// Return the ratio of the two sums...\n\t\tf += 'return f64_to_f32(s1/s2);';\n\t}\n\t// Close the function:\n\tf += '}';\n\n\t// Add a source directive for debugging:\n\tf += '//# sourceURL=evalrationalf.factory.js';\n\n\t// Create the function in the global scope:\n\treturn ( new Fcn( 'f64_to_f32', f ) )( float64ToFloat32 );\n\n\t/*\n\t*\tfunction evalrationalf( x ) {\n\t*\t\tvar ax, s1, s2;\n\t*\t\tif ( x === 0.0 ) {\n\t*\t\t\treturn f64_to_f32( P[0] / Q[0] );\n\t*\t\t}\n\t*\t\tif ( x < 0.0 ) {\n\t*\t\t\tax = -x;\n\t*\t\t} else {\n\t*\t\t\tax = x;\n\t*\t\t}\n\t*\t\tif ( ax <= 1.0 ) {\n\t*\t\t\ts1 = f64_to_f32(P[0]+f64_to_f32(x*f64_to_f32(P[1]+f64_to_f32(x*f64_to_f32(P[2]+f64_to_f32(x*f64_to_f32(P[3]+...+f64_to_f32(x*f64_to_f32(P[n-2]+f64_to_f32(x*P[n-1]))))))))));\n\t*\t\t\ts2 = f64_to_f32(Q[0]+f64_to_f32(x*(Q[1]+f64_to_f32(x*(Q[2]+f64_to_f32(x*(Q[3]+...+f64_to_f32(x*(Q[n-2]+f64_to_f32(x*Q[n-1]))))))))));\n\t*\t\t} else {\n\t*\t\t\tx = 1.0/x;\n\t*\t\t\ts1 = f64_to_f32(P[n-1]+f64_to_f32(x*(P[n-2]+f64_to_f32(x*(P[n-3]+f64_to_f32(x*(P[n-4]+...+f64_to_f32(x*(P[1]+f64_to_f32(x*P[0]))))))))));\n\t*\t\t\ts2 = f64_to_f32(Q[n-1]+f64_to_f32(x*(Q[n-2]+f64_to_f32(x*(Q[n-3]+f64_to_f32(x*(Q[n-4]+...+f64_to_f32(x*(Q[1]+f64_to_f32(x*Q[0]))))))))));\n\t*\t\t}\n\t*\t\treturn f64_to_f32( s1 / s2 );\n\t*\t}\n\t*/\n\n\t/**\n\t* Evaluates a rational function.\n\t*\n\t* @private\n\t* @param {number} x - value at which to evaluate a rational function\n\t* @returns {number} evaluated rational function\n\t*/\n\tfunction rational( x ) {\n\t\treturn evalrationalf( P, Q, x );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = factory;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Evaluate a rational function using single-precision floating-point arithmetic.\n*\n* @module @stdlib/math-base-tools-evalrationalf\n*\n* @example\n* var Float32Array = require( '@stdlib/array-float32' );\n* var evalrationalf = require( '@stdlib/math-base-tools-evalrationalf' );\n*\n* // 2x^3 + 4x^2 - 5x^1 - 6x^0 => degree 4\n* var P = new Float32Array( [ -6.0, -5.0, 4.0, 2.0 ] );\n*\n* // 0.5x^1 + 3x^0 => degree 2\n* var Q = new Float32Array( [ 3.0, 0.5, 0.0, 0.0 ] ); // zero-padded\n*\n* var v = evalrationalf( P, Q, 6.0 ); // => ( -6*6^0 - 5*6^1 + 4*6^2 + 2*6^3 ) / ( 3*6^0 + 0.5*6^1 + 0*6^2 + 0*6^3 ) = (-6-30+144+432)/(3+3)\n* // returns ~90.0\n*\n* @example\n* var Float32Array = require( '@stdlib/array-float32' );\n* var evalrationalf = require( '@stdlib/math-base-tools-evalrationalf' );\n*\n* var P = new Float32Array( [ 20.0, 8.0, 3.0 ] );\n* var Q = new Float32Array( [ 10.0, 9.0, 1.0 ] );\n*\n* var rational = evalrationalf.factory( P, Q );\n*\n* var v = rational( 10.0 ); // => (20*10^0 + 8*10^1 + 3*10^2) / (10*10^0 + 9*10^1 + 1*10^2) = (20+80+300)/(10+90+100)\n* // returns 2.0\n*\n* v = rational( 2.0 ); // => (20*2^0 + 8*2^1 + 3*2^2) / (10*2^0 + 9*2^1 + 1*2^2) = (20+16+12)/(10+18+4)\n* // returns 1.5\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar main = require( './main.js' );\nvar factory = require( './factory.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'factory', factory );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_main", "__commonJSMin", "exports", "module", "float64ToFloat32", "absf", "evalrationalf", "P", "Q", "x", "len", "s1", "s2", "i", "require_factory", "__commonJSMin", "exports", "module", "float64ToFloat32", "Fcn", "evalrationalf", "factory", "P", "Q", "f", "r", "n", "m", "i", "rational", "x", "setReadOnly", "main", "factory"]
}
